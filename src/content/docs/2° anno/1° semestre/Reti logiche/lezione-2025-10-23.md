---
title: Lezione (2025-10-23)
---

## Algorithmic State Machines (ASM)

Il diagramma ASM è simile ai diagrammi di flusso usati in programmazione.

Componenti:

- I rettangoli rappresentano gli stati e sono etichettati con:
  - un nome;
  - l'eventuale codifica;
  - i valori delle uscite (per le macchine di Moore, dato che non dipendono
    dagli ingressi);

- I rombi rappresentano una condizione sugli ingressi e generano 2 rami, a
  seconda del risultato.

- Le transizioni sono rappresentate da frecce che vanno da uno stato ad un
  altro, eventualmente passando per delle condizioni.

Ad ogni ciclo del clock, bisogna uscire da un rettangolo ed eseguire una
transizione (che può tornare anche al punto di partenza).

Riprendendo l'esempio della caldaia:

![Esempio di diagramma ASM](../../../../../images/reti-logiche/diagramma-asm-caldaia.png)

### Uscite condizionate

Per rappresentare macchine di Mealy, bisogna aggiungere delle uscite
condizionate dagli ingressi: un rettangolo ad angoli stondati specifica il
valore delle uscite durante le transizioni di stato.

L'uscita assume il valore corrispondente mentre il circuito è nello **stato di
partenza** della transizione.

![Esempio di diagramma ASM con uscite dipendenti dagli ingressi](../../../../../images/reti-logiche/diagramma-asm-mealy.png)

### Regole generali

Non si deve mai assegnare un valore agli ingressi. Per definizione non si può
decidere il valore di un ingresso.

![Esempio di circuito non corretto](../../../../../images/reti-logiche/asm-regola-1.png)

Non si deve mai usare un'uscita in una condizione di transizione.

![Esempio di circuito non corretto](../../../../../images/reti-logiche/asm-regola-2.png)

È possibile mettere 2 condizioni in sequenza sulla stessa transizione. È
importante però che la transizione finisca sempre su uno stato e non si crei un
ciclo composto solamente da condizioni.

Ogni stato definisce il valore dell'uscita. Per convenzione, se non si specifica
un valore, si assume sempre che essa ritorni a $0$.

## Circuiti sequenziali di base

### Registro parallelo

L'unità di memoria di base (che contiene un solo bit) è il flip-flop che abbiamo
già visto. Un gruppo di flip-flop correlati è detto **registro**.

![Simbolo circuitale del registro](../../../../../images/reti-logiche/simbolo-registro.png)

L'ingresso clear pone immediatamente il valore dell'uscita a $0$ (è asincrono),
fino al primo fronte attivo del clock in cui il segnale non è più presente.

#### Load-enable

Talvolta si vuole controllare per quali tick del clock si vuole caricare un
nuovo valore. Per fare ciò si deve mascherare il segnale del clock, facendolo
restare costante fintanto che si vuole mantenere fissato il valore dell'uscita.

**Problema**: Tutti i registri devono commutare nello stesso istante per evitare
comportamenti errati. Quindi generalmente si dovrebbero usare alberi di
distribuzione del segnale per bilanciare la distanza da ogni flip flop.

Quindi in sostanza è meglio non toccare il segnale di clock, se non per estreme
ottimizzazioni del circuito.

**Soluzione**: Invece che modificare il segnale del clock, è meglio usare un
multiplexer di fronte al flip-flop. Quindi se il segnale di load è attivo,
ritornerà il valore già memorizzato, altrimenti riprenderà il normale
funzionamento.

![Circuito del registro con multiplexer per load-enable](../../../../../images/reti-logiche/circuito-registro-load-enable-con-multiplexer.png)

### Registro a scorrimento (shift register)

In questo tipo di registro, i flip-flop sono collegati in serie e il caricamento
dei dati avviene un bit alla volta (per ciclo di clock).

I registri a scorrimento sono utilizzati spesso per la comunicazione seriale tra
periferiche (ad esempio protocolli USB e I2C).

![Circuito del registro a scorrimento](../../../../../images/reti-logiche/circuito-registro-scorrimento.png)

![Simbolo del registro a scorrimento](../../../../../images/reti-logiche/simbolo-registro-scorrimento.png)

#### Load-enable

Anche qua è pericoloso mascherare il clock, perchè il filo tra clock e flip-flop
è generalmente più lungo di quello tra un flip-flop e l'altro.

Quindi si può di nuovo aggiungere un multiplexer all'entrata di ogni cella di
memoria.

![Circuito del registro a scorrimento con load-enable](../../../../../images/reti-logiche/circuito-registro-scorrimento-load-enable.png)

#### Uscita parallela

Si può facilmente estrarre il dato memorizzato in parallelo tirando fuori un
uscita da ogni flip-flop invece che solamente da quello finale.

#### Ingresso parallelo

Per eseguire il caricamento il parallelo basta aggiungere un'altro ingresso al
multiplexer del load-enable.

Il multiplexer sarà ora controllato da 2 bit: uno per load-enable e l'altro per
scegliere tra ingresso seriale e parallelo.

#### SHR bidirezionale

L'uscita del flip-flop $n + 1$ viene collegata al multiplexer del $n$-esimo
flip-flop.

La tabella della verità del multiplexer (dove $s_0$ e $s_1$ sono gli ingressi di
controllo) diventa:

| $s_0$ | $s_1$ | modalità                                      |
| ----- | ----- | --------------------------------------------- |
| $0$   | $0$   | nessun cambiamento (load-enable disabilitato) |
| $0$   | $1$   | scorrimento all'indietro                      |
| $1$   | $0$   | caricamento parallelo                         |
| $1$   | $1$   | scorrimento in avanti                         |

![Circuito shr bidirezionale](../../../../../images/reti-logiche/circuito-shr-bidirezionale.png)

![Simbolo shr bidirezionale](../../../../../images/reti-logiche/simbolo-shr-bidirezionale.png)

### Contatore

Il contatore è un registro che segue una sequenza di stati all'applicazione di
una sequenza di impulsi come il segnale del clock.

Se la sequenza di stati è quella dei numeri binari, allora si parla di contatore
binario.

#### Contatore sincrono a modulo 16

È un circuito a 4 uscite che conta in binario da 0 a 15, incrementando di 1 ad
ogni ciclo del clock. Quando arriva a 15, l'uscita ritorna a 0 al ciclo
successivo.

Questo circuito non a ingressi (ad eccezione del clock). Un circuito sequenziale
può evolvere anche in mancanza di essi al contrario di uno combinatorio.

L'implementazione può essere quella di un registro parallelo affiancato ad un
sommatore tra il valore del registro e 1.

![Circuito del contatore](../../../../../images/reti-logiche/circuito-contatore.png)

Si può eventualmente aggiungere un segnale di count-enable per fermare
l'avanzamento della sequenza.

## Pattern sequenziali

Situazioni che succedono spesso sulle macchine a stati.

### Busy waiting

Si aspetta che un certo segnale S esegua una transizione, per esempio da 0 a 1.

![Diagramma ASM del busy waiting](../../../../../images/reti-logiche/diagramma-asm-busy-waiting.png)

La condizione appare soddisfatta solamente al ciclo di clock successivo al
cambiamento. Per avere un feedback istantaneo si può aggiungere un'uscita
condizionata collegata al valore dell'ingresso.

### Fire and check

Si fa partire un'operazione, e si aspetta che essa termini.

Si fa partire un contatore e si aspetta che esso arrivi al TC. Non ci interessa
il suo valore, solamente la condizione di TC.

![Diagramma ASM del fire and check](../../../../../images/reti-logiche/diagramma-asm-fire-and-check.png)

Si può usare per operazioni aritmetiche con floating point che spesso richiedono
multipli cicli di clock per raggiungere il risultato.
